<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">

<!-- Mirrored from blog.atom.io/2014/07/02/moving-atom-to-react.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Sep 2022 14:36:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../../css/application.css">
  <link rel="shortcut icon" href="../../../favicon.ico"/>
  <link type="application/atom+xml" rel="alternate" href="../../../feed.xml" title="Atom Blog" />
  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Moving Atom To React | Atom Blog</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Moving Atom To React" />
<meta name="author" content="nathansobo" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Performance is a top priority for the Atom team, and recently we’ve been focusing on making basic text editing smoother and more responsive. After some initial incremental progress, we decided to take a step back and rewrite the editor component’s view layer with a superior framework and a better understanding of the problem." />
<meta property="og:description" content="Performance is a top priority for the Atom team, and recently we’ve been focusing on making basic text editing smoother and more responsive. After some initial incremental progress, we decided to take a step back and rewrite the editor component’s view layer with a superior framework and a better understanding of the problem." />
<link rel="canonical" href="moving-atom-to-react.html" />
<meta property="og:url" content="moving-atom-to-react.html" />
<meta property="og:site_name" content="Atom Blog" />
<meta property="og:image" content="../../../img/posts/use-react-editor.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-07-02T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@AtomEditor" />
<meta name="twitter:creator" content="@nathansobo" />
<meta property="article:publisher" content="https://www.facebook.com/GitHub" />
<script type="application/ld+json">
{"@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.atom.io/2014/07/02/moving-atom-to-react.html"},"url":"https://blog.atom.io/2014/07/02/moving-atom-to-react.html","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://blog.atom.io/img/blog-logo.png"},"name":"nathansobo"},"headline":"Moving Atom To React","dateModified":"2014-07-02T00:00:00+00:00","datePublished":"2014-07-02T00:00:00+00:00","author":{"@type":"Person","name":"nathansobo"},"image":"https://blog.atom.io/img/posts/use-react-editor.png","description":"Performance is a top priority for the Atom team, and recently we’ve been focusing on making basic text editing smoother and more responsive. After some initial incremental progress, we decided to take a step back and rewrite the editor component’s view layer with a superior framework and a better understanding of the problem.","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-3769691-48', 'auto');
    ga('send', 'pageview');
  </script>
</head>
<body>

  <div class="footer-push">

    <div class="top-bar">
  <div class="wrapper">
    <ul class="navigation">
      <li><h1 title="Atom: A hackable text editor for the 21st Century"><a href="https://atom.io/" class="logo-small"></a></h1></li>
      <li><a href="https://atom.io/packages">Packages</a></li>
      <li><a href="https://atom.io/themes">Themes</a></li>
      <li><a href="https://atom.io/docs">Documentation</a></li>
      <li><a href="../../../index.html" class="is-selected">Blog</a></li>
      <li><a href="https://discuss.atom.io/">Discuss</a></li>
    </ul>

    <div class="top-bar-right">
      <a href="../../../feed.xml" class="rss-link"><span class="octicon octicon-rss"></span> Subscribe</a>
    </div>
  </div>
</div>


    <div class="wrapper content-push">
<div class="post">
  <h2 class="post-name">Moving Atom To React</h2>

  <p class="who-when">
    <span class="octicon octicon-calendar"></span> July 2, 2014 <a href="https://github.com/nathansobo" class="author-link"><img class="avatar avatar-small" alt="nathansobo" width="18" height="18" data-proofer-ignore="true" src="https://avatars1.githubusercontent.com/nathansobo?v=3&amp;s=18" srcset="https://avatars1.githubusercontent.com/nathansobo?v=3&s=18 1x, https://avatars1.githubusercontent.com/nathansobo?v=3&s=36 2x, https://avatars1.githubusercontent.com/nathansobo?v=3&s=54 3x, https://avatars1.githubusercontent.com/nathansobo?v=3&s=72 4x" /> nathansobo</a>
    <a href="https://twitter.com/share" class="twitter-share-button" data-via="AtomEditor">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  </p>
  <div class="post markdown">
    <style>
.heading { padding: 1em; background: #fffadb; }
img.use-react-editor { padding-top: 1em; }
strong { font-weight: bold; }
em { font-style: italic; }
</style>

<div class="heading">

<strong>tl;dr</strong> Atom has a new editor component, and we'll be enabling it
by default within the next couple of weeks. Please try it out by enabling
<em>"Use React Editor"</em> in the settings view and report any issues you
encounter to the <a href="https://github.com/atom/atom/issues">core team</a> and
package authors.

<img class="use-react-editor" src="../../../img/posts/use-react-editor.png" />

</div>

<p>Performance is a top priority for the Atom team, and recently we’ve been
focusing on making basic text editing smoother and more responsive. After some
initial incremental progress, we decided to take a step back and rewrite the
editor component’s view layer with a superior framework and a better
understanding of the problem.</p>

<h2 id="extra-reflows-kill-performance">Extra Reflows Kill Performance</h2>

<p>Writing fast JavaScript is not the sole factor in the performance of web
applications. If model changes aren’t efficiently translated into display
updates, even the fastest application logic and the cleverest data structures
aren’t enough. This is where we found ourselves with Atom’s editor rendering.</p>

<p>One of the biggest challenges we faced was eliminating unnecessary reflows.
<a href="http://www.stubbornella.org/content/2009/03/27/reflows-repaints-css-performance-making-your-javascript-slow/">Whole articles</a> have been written about this topic, but to briefly
summarize, a <em>reflow</em> describes style and layout calculations that the browser
has to perform whenever it reads from the DOM after the DOM is modified.
Ideally, for any given set of DOM operations, there’s only a single reflow
before new pixels are drawn to the screen. But if DOM reads and writes are
interleaved in a single synchronous chunk of JavaScript, we end up wasting time
performing more than a single reflow for a given display update. For example,
the timeline below shows an extra reflow that occurs in the old editor when
moving the cursor down causes the view to scroll.</p>

<p><img src="../../../img/posts/two-reflows.png" alt="reflows" /></p>

<p>We knew that if we wanted decent editor performance, we had to manage DOM
interaction more carefully and avoid extra reflows. Yet the complexity of the
editor and the fact that DOM updates were being augmented by external packages
continued to frustrate our efforts. Reflows kept creeping back in, and we had a
hard time reasoning about the ordering of reads and writes as we made changes to
the editor.</p>

<h2 id="subjugating-the-dom-with-react">Subjugating the DOM With React</h2>

<p>In our effort to banish reflows, we had two main problems to solve. First, we
needed to minimize reads from the DOM as much as possible. Second, we needed to
improve the discipline of DOM updates, giving ourselves a better ability to
reason about the order of reads and writes. Increasingly dissatisfied with our
existing, deliberately simple view framework, we decided to try <a href="http://facebook.github.io/react/">React</a>.</p>

<p>Right out of the box, React’s <a href="https://www.youtube.com/watch?v=-DX3vJiqxm4">virtual DOM</a> got us a long way
toward our goal of treating the DOM with kid gloves. Though we worked with raw
DOM nodes in a few places for performance and measurement reasons, it offered a
declarative abstraction that relieved us of the tedious state management
typically associated with DOM updates. In addition, React’s well-defined
reconciliation strategy and lifecycle hooks made it easy to reason about the
sequencing of the manual DOM interactions we did have to perform.</p>

<p>Rewriting also gave us a fresh chance to be much more stingy with our DOM reads.
For example, previously moving the cursor read the <code class="highlighter-rouge">scrollTop</code> and <code class="highlighter-rouge">scrollLeft</code>
of the editor’s <code class="highlighter-rouge">.scroll-view</code> element in order to determine if we needed to
auto-scroll. This time around, we represented scroll position in the model
layer, which allows us to make scrolling decisions directly in code that manages
the cursor object.</p>

<h2 id="minimizing-repaint-with-hardware-acceleration">Minimizing Repaint With Hardware Acceleration</h2>

<p>Another major performance obstacle in the old editor was time spent on repaints.
Chromium typically performs scrolling on the GPU, but this default optimization
wasn’t applied to Atom because we need to simulate scrolling by translating the
lines in order to only render the lines that are visible on screen. As a result,
every time the old editor scrolled even a little, the entire editor was
repainted on the CPU, which is visualized in red in this animated GIF.</p>

<p><img src="../../../img/posts/cpu-repaint.gif" alt="CPU scrolling" /></p>

<p>Chromium was also grouping the repaint of the cursor with the repaint of the
cursor position in the status bar whenever the cursor moved, slowing down cursor
movement.</p>

<p><img src="../../../img/posts/cpu-cursor-move.gif" alt="CPU cursor movement" /></p>

<p>To make the editor faster, it was critical that we shift more work from the CPU
to the GPU. After experimenting with several strategies, we found the best
approach was to render the div containing the lines as a single layer on the GPU
by applying a <code class="highlighter-rouge">translate3d</code> transform. We translate it up and down as the user
scrolls, absolutely positioning the visible lines in their correct location in
the layer. This combination convinces Chromium to confine its repaints only to
new areas of the screen, shifting any pre-existing content around with hardware
acceleration.</p>

<p><img src="../../../img/posts/gpu-repaint.gif" alt="GPU scrolling" /></p>

<p>We also render the cursors and the hidden input field that receives keyboard
events as their own layers on the GPU, allowing them to be composited with the
underlying lines in hardware. This prevents cursor translations from being
grouped with status bar updates, greatly improving cursor movement performance.</p>

<p><img src="../../../img/posts/gpu-cursor-move.gif" alt="GPU cursor movement" /></p>

<h2 id="new-apis-for-packages">New APIs for Packages</h2>

<p>Finally, we wanted to eliminate reflows from packages by providing performant,
officially-supported alternatives to direct DOM manipulation. We noticed that
most of the packages that manipulated the editor’s DOM were either adding
classes to lines and line numbers or rendering selection-like highlighted
regions behind certain ranges of text.</p>

<p>With the React editor, these kinds of changes can now be performed with the new
<a href="https://atom.io/docs/api/v0.107.0/api/classes/Editor.html#addDecorationForMarker-instance">decorations API</a>. Decorations allow metadata to be associated with
markers, instructing the editor to render classes on lines and line numbers, or
draw highlight regions. Using decorations is faster and more convenient than
manual DOM interactions, and we plan on introducing more APIs for common DOM
interactions going forward.</p>

<h2 id="next-steps">Next Steps</h2>

<p>In order to minimize disruption, we’re introducing the React-based editor on an
opt-in basis so that everyone has a chance to try it and make sure their
packages still work. If you check “Use React Editor” in your settings view, any
buffers you open thereafter will use the new code path. Please report any bugs
to the Atom team and to package authors so we can work together to make this a
smooth transition. We will enable the React editor by default in the next couple
weeks, keeping the old editor around as a fallback for a while before eventually
removing it entirely.</p>

<p>The new editor is faster in a number of ways, but we still have work to do
before we’re totally satisfied with performance. The improved structure of the
code will put us in a good position to apply more optimizations going forward.
We also plan on switching Atom’s workspace and pane system to React, which will
eliminate our dependency on jQuery in core and allow packages to implement their
views as React components. However, packages will never be required to use
React. We’ll support SpacePen for backward compatibility with existing views,
and we’ll be exploring some ideas for making Atom more
view-framework-agnostic for packages.</p>

<p>As we pledged when we launched the Atom beta, we’re going to do our best to make
life easy for package authors while remaining aggressive about pushing Atom
forward. Please help us keep that promise by test driving the React editor
today.</p>


  </div>
</div>

<div class="feedback">
  <p>Have feedback on this post? Let <a class="twitter-handle" href="https://twitter.com/intent/tweet?text=@AtomEditor%20&amp;related=atomeditor&amp;url=/2014/07/02/moving-atom-to-react.html">@AtomEditor</a> know on Twitter.</p>
  <p>Need help or found a bug? <a href="https://atom.io/contact">Contact us.</a></p>
</div>
</div>

    <div class="footer-pad"></div>
  </div>

  <footer>
  <div class="footer">
    <div class="wrapper">
      <ul class="footer-left">
        <li><a href="https://github.com/site/terms">Terms of Use</a></li>
        <li><a href="https://atom.io/releases">Releases</a></li>
        <li><a href="https://atom.io/faq">FAQ</a></li>
        <li><a href="https://atom.io/contact">Contact</a></li>
      </ul>

      <div class="footer-right">
        <a href="https://github.com/"><span class="octicon octicon-code"></span> with <span class="octicon octicon-heart"></span> by <span class="octicon octicon-logo-github"></span></a>
      </div>
    </div>
  </div>
</footer>

</body>

<!-- Mirrored from blog.atom.io/2014/07/02/moving-atom-to-react.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Sep 2022 14:36:37 GMT -->
</html>
